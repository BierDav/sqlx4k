package io.github.smyrgeorge.sqlx4k.processor

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import io.github.smyrgeorge.sqlx4k.Statement
import io.github.smyrgeorge.sqlx4k.annotation.Query
import kotlinx.coroutines.flow.Flow
import java.io.OutputStream
import kotlin.reflect.KClass

class RepositoryProcessor(
    private val options: Map<String, String>,
    private val logger: KSPLogger,
    private val codeGenerator: CodeGenerator,
) : SymbolProcessor {

    /**
     * Processes repository symbols annotated with a specific annotation, validates these symbols,
     * and generates Kotlin code for their associated functionality. The generated code is written
     * to a new file using a specified file name and package.
     *
     * @param resolver The `Resolver` instance used to discover and resolve symbols annotated
     *                 with the specified repository annotation.
     * @return A list of `KSAnnotated` symbols that could not be processed due to validation errors.
     */
    override fun process(resolver: Resolver): List<KSAnnotated> {
        val repoSymbols = resolver
            .getSymbolsWithAnnotation(TypeNames.REPOSITORY_ANNOTATION)
            .filterIsInstance<KSClassDeclaration>()
        if (!repoSymbols.iterator().hasNext()) return emptyList()

        val tableLookup = TableLookup(resolver)

        val outputPackage = options[TableProcessor.PACKAGE_OPTION]
            ?: error("Missing ${TableProcessor.PACKAGE_OPTION} option")
        logger.info("[RepositoryProcessor] Output package: $outputPackage")

        val useContextParameters = options[ENABLE_CONTEXT_PARAMETERS_OPTION]?.toBoolean() ?: false
        logger.info("[RepositoryProcessor] Enable context parameters: $useContextParameters")

        val globalCheckSqlSyntax = options[VALIDATE_SQL_SYNTAX_OPTION]?.toBoolean() ?: true
        logger.info("[RepositoryProcessor] Validate SQL syntax: $globalCheckSqlSyntax")

        val globalCheckSqlSchema = options[VALIDATE_SQL_SCHEMA_OPTION]?.toBoolean() ?: false
        logger.info("[RepositoryProcessor] Validate SQL schema: $globalCheckSqlSchema")
        val schemaMigrationsPath = options[SCHEMA_MIGRATIONS_PATH_OPTION] ?: "./set-the-path-to-schema-migrations"

        // Load schemas.
        if (globalCheckSqlSchema) SqlValidator.loadSchema(schemaMigrationsPath)

        val file: OutputStream = codeGenerator.createNewFile(
            // Make sure to associate the generated file with sources to keep/maintain it across incremental builds.
            // Learn more about incremental processing in KSP from the official docs:
            // https://kotlinlang.org/docs/ksp-incremental.html
            dependencies = Dependencies(false, *resolver.getAllFiles().toList().toTypedArray()),
            packageName = outputPackage,
            fileName = OUTPUT_FILENAME
        )

        file += "// Generated by sqlx4k-codegen (RepositoryProcessor)\n"
        @Suppress("DuplicatedCode")
        file += "@file:Suppress(\"unused\", \"RemoveRedundantQualifierName\", \"SqlNoDataSourceInspection\", \"SqlDialectInspection\")\n\n"
        file += "package $outputPackage\n\n"
        file += "import ${TypeNames.STATEMENT}\n"
        file += "import ${TypeNames.QUERY_EXECUTOR}\n"
        file += "import ${TypeNames.LISTEN_FOR_INVALIDATION}\n"
        file += "import ${TypeNames.CRUD_REPOSITORY}\n"
        file += "import ${TypeNames.HOOK_API}\n"
        file += "import ${TypeNames.HOOKS}\n"
        file += "import ${TypeNames.MUTABLE_HOOK_EVENT_BUS}\n"

        // For each repository interface, find methods annotated with @Query
        val validatedRepos = repoSymbols.filter { it.validate() }
        validatedRepos.forEach { repo ->
            if (repo.classKind != ClassKind.INTERFACE)
                error("@Repository is only supported on interfaces (${repo.qualifiedName()}).")

            // Extract domain and mapper from @Repository annotation on the interface
            val (domainDecl, mapperTypeName) = parseRepositoryAnnotation(repo, useContextParameters)

            // Find all methods declared in the interface
            val fnsAll = repo.declarations.filterIsInstance<KSFunctionDeclaration>().toList()

            // Determine implementation class name
            val implName = repo.simpleName() + "Impl"
            logger.info("[RepositoryProcessor] Generating implementation object $implName for ${repo.qualifiedName()}")

            // Emit class header
            file += "\nobject $implName : ${repo.qualifiedName()} {\n"

            // Generate @Query-based methods according to prefixes:
            // findAll/findAllBy/findOneBy/deleteBy/countBy/execute and also *All variants
            fnsAll
                .filter { fn -> fn.annotations.any { it.qualifiedName() == TypeNames.QUERY_ANNOTATION } }
                .forEach { fn ->
                    val queryAnn = fn.annotations.first { it.qualifiedName() == TypeNames.QUERY_ANNOTATION }
                    val localCheckSyntax = queryAnn.arguments
                        .firstOrNull { it.name?.asString() == "checkSyntax" }
                        ?.value as? Boolean ?: true
                    val localCheckSchema = queryAnn.arguments
                        .firstOrNull { it.name?.asString() == "checkSchema" }
                        ?.value as? Boolean ?: true
                    val doCheckSyntax = globalCheckSqlSyntax && localCheckSyntax
                    val doCheckSchema = globalCheckSqlSchema && localCheckSchema
                    emitQueryMethod(
                        file = file,
                        fn = fn,
                        validateSyntax = doCheckSyntax,
                        validateSchema = doCheckSchema,
                        mapperTypeName = mapperTypeName,
                        domainDecl = domainDecl,
                        useContextParameters = useContextParameters,
                        tableLookup = tableLookup,
                    )
                }

            // Generate CRUD methods: insert/update/delete;
            // Interface must implement CrudRepository<Domain> which we already validated.
            emitCrudMethods(
                file = file,
                domainDecl = domainDecl,
                mapperTypeName = mapperTypeName,
                useContextParameters = useContextParameters,
                tableLookup = tableLookup,
            )
            file += "}\n"
        }
        file.close()

        val unableToProcess = repoSymbols.filterNot { it.validate() }.toList()
        return unableToProcess
    }

    /**
     * Represents the valid prefixes for repository method names in the `RepositoryProcessor` class.
     *
     * These prefixes define the type of operation that a repository method performs, such as finding,
     * deleting, counting, or executing operations on a domain model. The primary usage of this enum
     * is to map method names to their corresponding behavior and ensure methods adhere to the expected
     * naming conventions in the repository interface.
     *
     * The valid prefixes are:
     * - `FIND_ALL`: Indicates methods that fetch all instances of a domain model.
     * - `DELETE_ALL`: Indicates methods that delete all instances of a domain model.
     * - `COUNT_ALL`: Indicates methods that count all instances of a domain model.
     * - `FIND_ALL_BY`: Indicates methods that fetch multiple instances of a domain model based on certain conditions.
     * - `FIND_ONE_BY`: Indicates methods that fetch a single instance of a domain model based on certain conditions.
     * - `DELETE_BY`: Indicates methods that delete instances of a domain model based on certain conditions.
     * - `COUNT_BY`: Indicates methods that count instances of a domain model based on certain conditions.
     * - `EXECUTE`: Indicates methods that perform a custom execution, typically associated with annotated SQL queries.
     *
     * This enum is used internally by the `RepositoryProcessor` to parse method names, validate method
     * signatures, and generate the appropriate method implementations for repository interfaces.
     */
    private enum class Prefix {
        FIND_ONE_BY,
        FIND_ONE_BY_FLOW,
        FIND_ALL_BY,
        FIND_ALL_BY_FLOW,
        FIND_ALL,
        FIND_ALL_FLOW,
        DELETE_BY,
        DELETE_ALL,
        COUNT_BY,
        COUNT_BY_FLOW,
        COUNT_ALL,
        COUNT_ALL_FLOW,
        EXECUTE
    }

    /**
     * Parses the method name to determine its prefix and maps it to the corresponding `Prefix` enumeration value.
     * The method identifies valid repository method prefixes such as `findAll`, `deleteAll`, `countAll`, and more,
     * as well as prefixes that start with specific patterns like `findAllBy`, `findOneBy`, etc.
     * If the method name doesn't match any valid prefix, an error is thrown.
     *
     * @param name The name of the repository method that needs to be parsed.
     * @return The detected `Prefix` value corresponding to the method prefix.
     * @throws IllegalStateException if the method name does not correspond to a valid repository method prefix.
     */
    private fun parseMethodPrefix(name: String): Prefix = when {
        name == "findAll" -> Prefix.FIND_ALL
        name == "findAllFlow" -> Prefix.FIND_ALL_FLOW
        name == "deleteAll" -> Prefix.DELETE_ALL
        name == "countAll" -> Prefix.COUNT_ALL
        name == "countAllFlow" -> Prefix.COUNT_ALL_FLOW
        name.startsWith("findAllBy") && name.endsWith("Flow") -> Prefix.FIND_ALL_BY_FLOW
        name.startsWith("findAllBy") -> Prefix.FIND_ALL_BY
        name.startsWith("findOneBy") && name.endsWith("Flow") -> Prefix.FIND_ONE_BY_FLOW
        name.startsWith("findOneBy") -> Prefix.FIND_ONE_BY
        name.startsWith("deleteBy") -> Prefix.DELETE_BY
        name.startsWith("countBy") && name.endsWith("Flow") -> Prefix.COUNT_BY_FLOW
        name.startsWith("countBy") -> Prefix.COUNT_BY
        name.startsWith("execute") -> Prefix.EXECUTE
        else -> error("Invalid repository method name '$name'. Must be one of: findAll, deleteAll, countAll or start with: findAllBy, findOneBy, deleteBy, countBy, execute.")
    }

    /**
     * Parses the `@Repository` annotation on the provided repository interface, validates its conformance to the
     * expected structure, and extracts the associated domain type and mapper information.
     *
     * This method ensures that the annotated repository interface extends the correct base interface
     * (e.g., `CrudRepository` or `ContextCrudRepository`) with a valid domain type parameter. Additionally,
     * it verifies that the domain type is annotated with `@Table` and that a mapper is explicitly declared within
     * the `@Repository` annotation.
     *
     * @param repo The repository interface represented as a `KSClassDeclaration`. This class declaration must
     *             be annotated with `@Repository` and implement the appropriate `CrudRepository` interface.
     * @param useContextParameters A flag indicating whether the `ContextCrudRepository` interface
     *                              is being used instead of the standard `CrudRepository`.
     * @return A pair containing the `KSClassDeclaration` of the domain type associated with the repository and
     *         the fully qualified name of the mapper type specified in the `@Repository` annotation.
     * @throws IllegalStateException if the repository interface does not conform to the expected structure, such as
     *         - Missing `@Repository` annotation
     *         - Not extending the appropriate `CrudRepository` interface
     *         - Incorrectly specified domain type
     *         - Domain type not annotated with `@Table`
     *         - Missing or unresolved mapper type in the `@Repository` annotation
     */
    private fun parseRepositoryAnnotation(
        repo: KSClassDeclaration,
        useContextParameters: Boolean
    ): Pair<KSClassDeclaration, String> {
        fun implementsCrudRepository(repo: KSClassDeclaration): KSClassDeclaration {
            val repoTypeName =
                if (useContextParameters) TypeNames.CONTEXT_CRUD_REPOSITORY
                else TypeNames.CRUD_REPOSITORY
            val repoSimpleName = repoTypeName.substringAfterLast(".")
            // find CrudRepository<T> or ContextCrudRepository<T>
            val st = repo.superTypes.map { it.resolve() }
                .firstOrNull { it.declaration.qualifiedName() == repoTypeName }
                ?: error("@Repository interface ${repo.qualifiedName()} must extend $repoTypeName<T>")
            val typeArg = st.arguments.firstOrNull()?.type?.resolve()
                ?: error("${repo.qualifiedName()} implements $repoSimpleName without type argument; expected $repoSimpleName<T>")
            val domainDecl = typeArg.declaration as? KSClassDeclaration
                ?: error("$repoSimpleName type argument must be a class on ${repo.qualifiedName()}")
            // ensure @Table
            val hasTable = domainDecl.annotations.any {
                val qn = it.qualifiedName()
                qn == TypeNames.TABLE_ANNOTATION
            }
            if (!hasTable) error("$repoSimpleName generic parameter must be @Table-annotated (${domainDecl.qualifiedName()})")
            return domainDecl
        }

        val repoAnn = repo.annotations.firstOrNull { it.qualifiedName() == TypeNames.REPOSITORY_ANNOTATION }
            ?: error("Missing @Repository annotation on interface ${repo.qualifiedName()}")

        // Enforce that the interface extends CrudRepository<T> and derive domain from T
        val domainDecl = implementsCrudRepository(repo)

        val mapperArg: KSValueArgument? = repoAnn.arguments.firstOrNull { it.name?.asString() == "mapper" }
        val mapperKSType = mapperArg?.value as? KSType
            ?: error("@Repository must declare a mapper, e.g. @Repository(mapper = FooRowMapper::class) on ${repo.qualifiedName()}")
        val mapperTypeName = mapperKSType.declaration.qualifiedName()
            ?: error("Unable to resolve mapper type for ${repo.qualifiedName()}")
        return domainDecl to mapperTypeName
    }

    /**
     * Validates the context parameter for a given function declaration based on the specified mode.
     *
     * @param fn The function declaration to validate.
     * @param useContextParameters A flag indicating whether context parameters mode is enabled.
     */
    private fun validateContextParameter(
        fn: KSFunctionDeclaration,
        useContextParameters: Boolean
    ) {
        val name = fn.simpleName()
        val params = fn.parameters
        if (useContextParameters) {
            // TODO: somehow validate that method has context(context: QueryExecutor).
            // Ensure there is no explicit parameter of type QueryExecutor named 'context'
            val hasExplicitContextParam = params.any { p ->
                val pType = p.type.resolve()
                val qn = pType.declaration.qualifiedName()
                val pName = p.name?.asString()
                qn == TypeNames.QUERY_EXECUTOR && pName == "context"
            }
            if (hasExplicitContextParam) {
                error("${fn.getLocationLink()}: Repository method '$name' must not declare parameter 'context: ${TypeNames.QUERY_EXECUTOR}' when using context parameters")
            }
            return
        }
        // Non-context-parameters mode: the first parameter must be 'context: QueryExecutor'
        if (params.isEmpty())
            error("${fn.getLocationLink()}: Repository method '$name' must declare first parameter 'context: ${TypeNames.QUERY_EXECUTOR}'")
        val first = params.first()
        val firstName = first.name?.asString()
            ?: error("${fn.getLocationLink()}: Repository method '$name' first parameter must be named 'context'")
        if (firstName != "context")
            error("${fn.getLocationLink()}: Repository method '$name' first parameter must be named 'context'")
        val firstType = first.type.resolve()
        val firstQn = firstType.declaration.qualifiedName()
            ?: error("${fn.getLocationLink()}: Unable to resolve type of first parameter for method '$name'")
        if (firstQn != TypeNames.QUERY_EXECUTOR || firstType.isMarkedNullable)
            error("${fn.getLocationLink()}: Repository method '$name' first parameter must be non-null ${TypeNames.QUERY_EXECUTOR}")
    }

    /**
     * Validates the return type of a repository method based on its prefix and domain type.
     *
     * @param prefix The prefix of the method, used to determine its behavior and expected return type.
     * @param fn The function declaration representing the repository method to validate.
     * @param domainDecl The class declaration of the repository's domain type.
     */
    private fun validateReturnType(
        prefix: Prefix,
        fn: KSFunctionDeclaration,
        domainDecl: KSClassDeclaration
    ) {
        val name = fn.simpleName()
        val returnType = fn.returnType?.resolve()
            ?: error("${fn.getLocationLink()}: Unable to resolve return type for method '$name'")

        fun ensureResult(inner: KSType, isFlow: Boolean): KSType {
            val expectedType = if(isFlow) "${Flow::class.qualifiedName}<${Result::class.qualifiedName}<...>>" else "${Result::class.qualifiedName}<...>"
            var start = inner
            if (isFlow) {
                if (inner.declaration.qualifiedName() != TypeNames.KOTLIN_FLOW || inner.isMarkedNullable)
                    error("${fn.getLocationLink()}: Repository method '$name' must return $expectedType but returns '$returnType'")
                start = returnType.arguments.firstOrNull()?.type?.resolve()
                    ?: error("${fn.getLocationLink()}: Repository method '$name' must return $expectedType with a type argument")
            }
            val resultQName = start.declaration.qualifiedName()
                ?: error("${fn.getLocationLink()}: Unable to resolve return type declaration for method '$name'")
            if (resultQName != TypeNames.KOTLIN_RESULT)
                error("${fn.getLocationLink()}: Repository method '$name' must return $expectedType but returns '$returnType'")
            val result = start.arguments.firstOrNull()?.type?.resolve()
                ?: error("${fn.getLocationLink()}: Repository method '$name' must return $expectedType with a type argument")
            return result
        }

        fun ensureDomain(inner: KSType, allowNullable: Boolean) {
            val innerDecl = inner.declaration as? KSClassDeclaration
                ?: error("${fn.getLocationLink()}: Unable to resolve inner domain type for method '$name'")
            val innerQn = innerDecl.qualifiedName()
                ?: error("${fn.getLocationLink()}: Unable to resolve inner domain type name for method '$name'")
            val domainQn = domainDecl.qualifiedName()
                ?: error("${fn.getLocationLink()}: Unable to resolve repository domain type name")
            if (innerQn != domainQn)
                error("${fn.getLocationLink()}: Method '$name' must use repository domain type '$domainQn' but found '$innerQn'")
            if (!allowNullable && inner.isMarkedNullable)
                error("${fn.getLocationLink()}: Method '$name' domain return type must be non-nullable")
        }

        when (prefix) {
            Prefix.FIND_ALL, Prefix.FIND_ALL_BY -> {
                val r0 = ensureResult(returnType, false)
                val listQn = r0.declaration.qualifiedName()
                    ?: error("${fn.getLocationLink()}: Unable to resolve inner type for method '$name'")
                if (listQn != TypeNames.KOTLIN_LIST || r0.isMarkedNullable)
                    error("${fn.getLocationLink()}: Method '$name' must return Result<List<T>> where T is the repository domain type")
                val tArg = r0.arguments.firstOrNull()?.type?.resolve()
                    ?: error("${fn.getLocationLink()}: Method '$name' must return Result<List<T>> with a generic argument")
                ensureDomain(tArg, allowNullable = false)
            }

            Prefix.FIND_ALL_FLOW, Prefix.FIND_ALL_BY_FLOW -> {
                val r0 = ensureResult(returnType, true)
                if (r0.declaration.qualifiedName() != TypeNames.KOTLIN_LIST || r0.isMarkedNullable)
                    error("${fn.getLocationLink()}: Method '$name' must return Flow<Result<List<T>>> where T is the repository domain type")
                val tArg = r0.arguments.firstOrNull()?.type?.resolve()
                    ?: error("${fn.getLocationLink()}: Method '$name' must return Flow<Result<List<T>>> with a generic argument")
                ensureDomain(tArg, allowNullable = false)
            }

            Prefix.FIND_ONE_BY -> {
                val r0 = ensureResult(returnType, false)
                ensureDomain(r0.makeNotNullable(), allowNullable = true)
                if (!r0.isMarkedNullable)
                    error("${fn.getLocationLink()}: Method '$name' must return Result<T?> where T is the repository domain type")
            }

            Prefix.FIND_ONE_BY_FLOW -> {
                val r0 = ensureResult(returnType, true)
                if (r0.declaration.qualifiedName() != TypeNames.KOTLIN_FLOW || r0.isMarkedNullable)
                    error("${fn.getLocationLink()}: Method '$name' must return Flow<Result<List<T>>> where T is the repository domain type")
                val tArg = r0.arguments.firstOrNull()?.type?.resolve()
                    ?: error("${fn.getLocationLink()}: Method '$name' must return Flow<Result<List<T>>> with a generic argument")
                ensureDomain(tArg.makeNotNullable(), allowNullable = true)
                if (!tArg.isMarkedNullable)
                    error("${fn.getLocationLink()}: Method '$name' must return Flow<Result<T?>> where T is the repository domain type")
            }

            Prefix.DELETE_ALL, Prefix.COUNT_ALL, Prefix.DELETE_BY, Prefix.COUNT_BY, Prefix.EXECUTE -> {
                val r0 = ensureResult(returnType, false)
                val qn0 = r0.declaration.qualifiedName()
                    ?: error("${fn.getLocationLink()}: Unable to resolve inner type for method '$name'")
                if (qn0 != TypeNames.KOTLIN_LONG || r0.isMarkedNullable)
                    error("${fn.getLocationLink()}: Method '$name' with prefix '${prefix.name.lowercase()}' must return Result<Long>")
            }

            Prefix.COUNT_ALL_FLOW, Prefix.COUNT_BY_FLOW -> {
                val r0 = ensureResult(returnType, true)
                if (r0.declaration.qualifiedName() != TypeNames.KOTLIN_LONG || r0.isMarkedNullable)
                    error("${fn.getLocationLink()}: Method '$name' with prefix '${prefix.name.lowercase()}' must return Flow<Result<Long>>")
            }
        }
    }

    /**
     * Validates the arity of the parameters in a repository method based on its prefix and other constraints.
     *
     * @param prefix The prefix of the method, which determines the expected parameter count and validation rules.
     * @param fn The function declaration to validate.
     * @param useContextParameters A flag indicating whether the method uses context parameters.
     *      If true, context parameters are excluded from standard parameter arity validation.
     */
    private fun validateParameterArity(
        prefix: Prefix,
        fn: KSFunctionDeclaration,
        useContextParameters: Boolean
    ) {
        val name = fn.simpleName()
        val params = fn.parameters
        val nonContextCount = if (useContextParameters) params.size else params.size - 1
        when (prefix) {
            Prefix.FIND_ALL, Prefix.FIND_ALL_FLOW,
            Prefix.COUNT_ALL, Prefix.COUNT_ALL_FLOW,
            Prefix.DELETE_ALL,
                -> if (nonContextCount != 0) error("${fn.getLocationLink()}: Method '$name' must not have parameters other than context")

            Prefix.FIND_ALL_BY, Prefix.FIND_ALL_BY_FLOW,
            Prefix.FIND_ONE_BY, Prefix.FIND_ONE_BY_FLOW,
            Prefix.COUNT_BY, Prefix.COUNT_BY_FLOW,
            Prefix.DELETE_BY,
                -> if (nonContextCount < 1) error(
                "${fn.getLocationLink()}: Method '$name' must have more than one argument (at least one after context)"
            )

            Prefix.EXECUTE -> {}
        }
    }

    /**
     * Validates the parameters in a repository method in the context of a SQL query.
     *
     * This method checks the compatibility between the parameters declared in a repository method
     * and the named parameters used in the associated SQL query.
     *
     * @param sql The SQL query string associated with the repository method.
     * @param fn The repository method declaration (`KSFunctionDeclaration`) containing parameters to be validated.
     * @param useContextParameters A flag indicating whether the method uses context parameters. If `true`,
     *                              the first parameter (assumed to be the context parameter) is excluded from validation.
     * @throws IllegalStateException If:
     * - Positional parameters are used in the SQL query.
     * - The number of method parameters does not match the number of named parameters in the SQL query.
     * - Any method parameter is missing a corresponding named parameter in the SQL query.
     * - Any method parameter lacks a name.
     */
    private fun validateParameters(
        sql: String,
        fn: KSFunctionDeclaration,
        useContextParameters: Boolean
    ) {
        val name = fn.simpleName()
        val statement = Statement.create(sql)
        if (statement.extractedPositionalParameters > 0)
            error("${fn.getLocationLink()}: Method '$name' uses positional parameters in @Query (only named parameters are supported).")
        // Exclude 'context' argument.
        val parameters = if (useContextParameters) fn.parameters else fn.parameters.drop(1)
        if (parameters.size != statement.extractedNamedParameters.size)
            error("${fn.getLocationLink()}: Method '$name' has ${parameters.size} parameters but @Query statement has ${statement.extractedNamedParameters.size} named parameters.")
        parameters.forEach { p ->
            val pName = p.name?.asString()
                ?: error("${fn.getLocationLink()}: All query parameters must be named when using namedParameters support")
            if (!statement.extractedNamedParameters.contains(pName))
                error("${fn.getLocationLink()}: Method '$name' has parameter '$pName' but @Query statement does not contain a named parameter with that name.")
        }
    }

    private fun validateModifiers(
        prefix: Prefix,
        fn: KSFunctionDeclaration
    ) {
        val name = fn.simpleName()
        val isSuspending = fn.modifiers.contains(Modifier.SUSPEND)
        when (prefix) {
            Prefix.FIND_ALL, Prefix.FIND_ALL_BY, Prefix.FIND_ONE_BY,
            Prefix.COUNT_ALL, Prefix.COUNT_BY,
            Prefix.DELETE_ALL, Prefix.DELETE_BY,
            Prefix.EXECUTE
                ->
                if (!isSuspending)
                    error("${fn.getLocationLink()}: Method '$name' must be suspending")

            Prefix.FIND_ALL_FLOW, Prefix.FIND_ALL_BY_FLOW,
            Prefix.COUNT_ALL_FLOW, Prefix.FIND_ONE_BY_FLOW,
            Prefix.COUNT_BY_FLOW -> {
                if (isSuspending)
                    error("${fn.getLocationLink()}: Method '$name' mustn't be suspending")
            }
        }
    }

    /**
     * Emits named parameter bindings for a given list of parameters into the specified output stream.
     * This method assumes that parameters after the first one must be named and generates binding statements accordingly.
     *
     * @param file The OutputStream where the named parameter-binding statements will be written.
     * @param params A list of KSValueParameter objects representing the parameters for which bindings are generated. The first parameter is excluded from processing.
     */
    private fun emitNamedParameterBindings(
        file: OutputStream,
        params: List<KSValueParameter>
    ) {
        params.drop(1).forEach { p ->
            val pName = p.name?.asString()
                ?: error("All query parameters must be named when using namedParameters support")
            file += "        statement.bind(\"$pName\", $pName)\n"
        }
    }

    /**
     * Generates the implementation of a repository method annotated with `@Query`.
     *
     * @param file The output stream where the generated method will be written.
     * @param fn The function declaration representing the annotated method.
     * @param validateSyntax A flag indicating whether the SQL syntax should be validated.
     * @param validateSchema A flag indicating whether the SQL query should be validated against the schema.
     * @param mapperTypeName The name of the mapper used for mapping query results.
     * @param domainDecl The class declaration representing the domain entity associated with this repository.
     * @param useContextParameters A flag indicating whether context parameters are used in the generated method.
     */
    private fun emitQueryMethod(
        file: OutputStream,
        fn: KSFunctionDeclaration,
        validateSyntax: Boolean,
        validateSchema: Boolean,
        mapperTypeName: String,
        domainDecl: KSClassDeclaration,
        useContextParameters: Boolean,
        tableLookup: TableLookup
    ) {
        val name = fn.simpleName()
        val prefix: Prefix = parseMethodPrefix(name)
        logger.info("[RepositoryProcessor] Generating @Query method: $name")

        val queryAnnotation = fn.annotations.first { it.qualifiedName() == TypeNames.QUERY_ANNOTATION }
        val sql: String = queryAnnotation
            .arguments.firstOrNull { it.name?.asString() == "value" }
            ?.value as? String
            ?: error("Unable to generate query method (could not extract sql query from the @Query): $fn")

        val params = fn.parameters
        val paramSig = params.joinToString { p ->
            val pName = p.name?.asString() ?: "p"
            val pType = p.type.toString()
            "$pName: $pType"
        }

        validateModifiers(prefix, fn)
        validateContextParameter(fn, useContextParameters)
        validateParameterArity(prefix, fn, useContextParameters)
        validateParameters(sql, fn, useContextParameters)
        validateReturnType(prefix, fn, domainDecl)
        if (validateSyntax) SqlValidator.validateQuerySyntax(fn.simpleName(), sql)
        if (validateSchema) SqlValidator.validateQuerySchema(fn.simpleName(), sql)

        val analysis = SqlValidator.analyseQuery(sql)
        if (analysis == null)
            logger.warn("[RepositoryProcessor] Unable to analyze SQL query (${fn.simpleName()}): $sql")

        val isIndependent = (queryAnnotation.arguments
            .firstOrNull { it.name?.asString() == Query::isIndependent.name }
            ?.value as? Boolean) ?: false
        val explicitDependentTables = queryAnnotation.arguments
            .firstOrNull { it.name?.asString() == Query::explicitDependentTables.name }
            ?.value as? Array<KClass<*>>
        if (isIndependent && explicitDependentTables != null && explicitDependentTables.isNotEmpty())
            error("Query marked as independent mustn't specify explicitDependentTables: $fn")
        var dependentTables = explicitDependentTables?.mapNotNull { it.qualifiedName }
        
        if (dependentTables == null) {
            dependentTables = analysis?.dependentTables?.mapNotNull {
                val result = tableLookup[it]
                if (result == null)
                    logger.warn("[RepositoryProcessor] Unable to find dependent table with name $it. Check your @Table annotation. Mind that names are case-sensitive.")
                result?.qualifiedName()
            }

            if (dependentTables != null && dependentTables.isEmpty())
                logger.warn("[RepositoryProcessor] Query analysis returned no dependent tables. Please provide explicit dependencies (${fn.simpleName()}): $sql")

        }
        
        var dependentTablesArg = ""
        if (!isIndependent && dependentTables != null && dependentTables.isNotEmpty())
            dependentTablesArg = dependentTables.joinToString(", ") { "$it::class" }

        logger.info("[RepositoryProcessor] Emitting method '$name' with prefix ${prefix.name} in ${domainDecl.qualifiedName()} using mapper $mapperTypeName")

        // Generate KDoc
        file += "    /**\n"
        file += "     * Generated implementation of [$name]\n"
        file += "     *\n"
        file += "     * SQL: `$sql`\n"
        file += "     *\n"
        if (!useContextParameters) {
            file += "     * @param context The query executor (database connection or transaction)\n"
        }
        params.drop(if (useContextParameters) 0 else 1).forEach { p ->
            val pName = p.name?.asString() ?: "param"
            file += "     * @param $pName Query parameter\n"
        }
        val returnDesc = when (prefix) {
            Prefix.FIND_ALL, Prefix.FIND_ALL_BY -> "Result containing list of ${domainDecl.simpleName()} entities"
            Prefix.FIND_ALL_FLOW, Prefix.FIND_ALL_BY_FLOW -> "Result containing a flow which emits a list of ${domainDecl.simpleName()} entities once and everytime the underlying table gets invalidated"
            Prefix.FIND_ONE_BY -> "Result containing a single ${domainDecl.simpleName()} entity or null if not found"
            Prefix.FIND_ONE_BY_FLOW -> "Flow that emits a Result containing a single ${domainDecl.simpleName()} entity or null if not found once and everytime the underlying table gets invalidated"
            Prefix.DELETE_ALL, Prefix.DELETE_BY, Prefix.EXECUTE -> "Result containing the number of affected rows"
            Prefix.COUNT_ALL, Prefix.COUNT_BY -> "Result containing the count"
            Prefix.COUNT_ALL_FLOW, Prefix.COUNT_BY_FLOW -> "Flow that emits a Result containing the count once and everytime the underlying table gets invalidated"
        }
        file += "     * @return $returnDesc, or an error if the operation fails\n"
        file += "     */\n"

        if (useContextParameters) {
            file += "    context(context: QueryExecutor)\n"
        }

        val suspendModifier = when (prefix) {
            Prefix.FIND_ALL, Prefix.FIND_ALL_BY, Prefix.FIND_ONE_BY,
            Prefix.COUNT_ALL, Prefix.COUNT_BY,
            Prefix.DELETE_ALL, Prefix.DELETE_BY,
            Prefix.EXECUTE -> "suspend "

            Prefix.FIND_ALL_FLOW, Prefix.FIND_ALL_BY_FLOW,
            Prefix.COUNT_ALL_FLOW, Prefix.FIND_ONE_BY_FLOW,
            Prefix.COUNT_BY_FLOW -> ""
        }

        file += "    override ${suspendModifier}fun $name($paramSig) = run {\n"
        file += "        // language=SQL\n"
        file += "        val statement = Statement.create(\"$sql\")\n"
        emitNamedParameterBindings(file, params)

        val contextParamName =
            if (useContextParameters) "context"
            else params.firstOrNull()?.name?.asString() ?: "context"



        when (prefix) {
            Prefix.FIND_ALL, Prefix.FIND_ALL_BY -> {
                file += "        $contextParamName.fetchAll(statement, $mapperTypeName)\n"
            }

            Prefix.FIND_ALL_FLOW, Prefix.FIND_ALL_BY_FLOW -> {
                file += """        $contextParamName.listenForInvalidation(${dependentTablesArg}) { 
                                       fetchAll(statement, $mapperTypeName) 
                                   }
                        """.trimIndent()
            }

            Prefix.FIND_ONE_BY -> {
                file += """        $contextParamName.fetchAll(statement, $mapperTypeName).map { list ->
                                       when (list.size) {
                                           0 -> null
                                           1 -> list.first()
                                           else -> return@run Result.failure(IllegalStateException("findOneBy query returned more than one row"))
                                       }
                                   }
                        """.trimIndent()
            }

            Prefix.FIND_ONE_BY_FLOW -> {
                file += """        $contextParamName.listenForInvalidation(${dependentTablesArg}) {     
                                        fetchAll(statement, $mapperTypeName).map { list ->
                                             when (list.size) {
                                                 0 -> null
                                                 1 -> list.first()
                                                 else -> return@listenForInvalidation Result.failure(IllegalStateException("findOneBy query returned more than one row"))
                                             }
                                        }
                                   }
                        """.trimIndent()
            }

            Prefix.DELETE_ALL, Prefix.DELETE_BY, Prefix.EXECUTE -> {
                file += """         val hook = if (context is HookApi) context.hook as MutableHookEventBus else null
                                    hook?.publish { Hooks.Repository.BeforeCrudRepoHook(listOf($dependentTablesArg), context) }
                                    val result = $contextParamName.execute(statement)
                                    hook?.publish { Hooks.Repository.AfterCrudRepoHook(listOf($dependentTablesArg), result, context) }
                                    result
                        """.trimIndent()
            }

            Prefix.COUNT_ALL, Prefix.COUNT_BY -> {
                file += """        $contextParamName.fetchAll(statement).map { rs ->
                                        val row = rs.firstOrNull()
                                            ?: return@run Result.failure(IllegalStateException("Count query returned no rows"))
                                        row.get(0).asString().toLong()
                                    }   
                            """.trimIndent()
            }

            Prefix.COUNT_ALL_FLOW, Prefix.COUNT_BY_FLOW -> {
                file += """         $contextParamName.listenForInvalidation(${dependentTablesArg}) {     
                                        fetchAll(statement).map { rs ->
                                            val row = rs.firstOrNull()
                                                ?: return@listenForInvalidation Result.failure(IllegalStateException("Count query returned no rows"))
                                            row.get(0).asString().toLong()
                                        }
                                    }
                            """.trimIndent()
            }
        }
        file += "    }\n"
    }

    /**
     * Generates CRUD methods (insert, update, delete, save) for the provided domain class and writes
     * the method definitions to the specified output stream.
     *
     * @param file the output stream where the generated CRUD methods will be written
     * @param domainDecl the class declaration of the domain object for which CRUD methods are generated
     * @param mapperTypeName the name of the mapper type used to map query results to the domain object
     * @param useContextParameters whether to include `QueryExecutor` as a context parameter in the method signatures
     */
    private fun emitCrudMethods(
        file: OutputStream,
        domainDecl: KSClassDeclaration,
        mapperTypeName: String,
        useContextParameters: Boolean,
        tableLookup: TableLookup
    ) {
        val domainQn = domainDecl.qualifiedName() ?: error("Cannot resolve domain type name")
        val domainSimpleName = domainDecl.simpleName()
        logger.info("[RepositoryProcessor] Generating CRUD methods for $domainQn")

        val dependentTablesArg = "$domainQn::class"

        // insert
        logger.info("[RepositoryProcessor] Emitting CRUD method: insert($domainQn)")
        file += "    /**\n"
        file += "     * Inserts a new $domainSimpleName entity into the database.\n"
        file += "     *\n"
        file += "     * Executes an INSERT statement and returns the inserted entity with any\n"
        file += "     * generated values (e.g., auto-incremented IDs) populated.\n"
        file += "     *\n"
        if (!useContextParameters) {
            file += "     * @param context The query executor (database connection or transaction)\n"
        }
        file += "     * @param entity The $domainSimpleName entity to insert\n"
        file += "     * @return Result containing the inserted $domainSimpleName with generated values,\n"
        file += "     *         or an error if the insert operation fails\n"
        file += "     */\n"
        if (useContextParameters) {
            file += "    context(context: QueryExecutor)\n"
            file += "    override suspend fun insert(entity: $domainQn) = run {\n"
        } else {
            file += "    override suspend fun insert(context: QueryExecutor, entity: $domainQn) = run {\n"
        }
        file += """        val hook = if (context is HookApi) context.hook as MutableHookEventBus else null
                           hook?.publish { CrudRepository.BeforeInsertHook(entity, listOf($dependentTablesArg), context) }
                           val statement = entity.insert()
                           val result = context.fetchAll(statement, $mapperTypeName).map { list ->
                               val one = list.firstOrNull()
                                   ?: return@run Result.failure(IllegalStateException("Insert query returned no rows"))
                               one
                           }
                           hook?.publish { CrudRepository.AfterInsertHook(entity, listOf($dependentTablesArg), result, context) }
                           result
                       }
                   """.trimIndent()

        // update
        logger.info("[RepositoryProcessor] Emitting CRUD method: update($domainQn)")
        file += "    /**\n"
        file += "     * Updates an existing $domainSimpleName entity in the database.\n"
        file += "     *\n"
        file += "     * Executes an UPDATE statement based on the entity's ID and returns\n"
        file += "     * the updated entity with any modified values.\n"
        file += "     *\n"
        if (!useContextParameters) {
            file += "     * @param context The query executor (database connection or transaction)\n"
        }
        file += "     * @param entity The $domainSimpleName entity to update\n"
        file += "     * @return Result containing the updated $domainSimpleName entity,\n"
        file += "     *         or an error if the update operation fails\n"
        file += "     */\n"
        if (useContextParameters) {
            file += "    context(context: QueryExecutor)\n"
            file += "    override suspend fun update(entity: $domainQn) = run {\n"
        } else {
            file += "    override suspend fun update(context: QueryExecutor, entity: $domainQn) = run {\n"
        }
        file += """        val hook = if (context is HookApi) context.hook as MutableHookEventBus else null
                           hook?.publish { CrudRepository.BeforeUpdateHook(entity, listOf($dependentTablesArg), context) }
                           val statement = entity.update()
                           val result = context.fetchAll(statement, $mapperTypeName).map { list ->
                               val one = list.firstOrNull()
                                   ?: return@run Result.failure(IllegalStateException("Update query returned no rows"))
                               one
                           }
                           hook?.publish { CrudRepository.AfterUpdateHook(entity, listOf($dependentTablesArg), result, context) }
                           result
                       }
                   """

        // delete
        logger.info("[RepositoryProcessor] Emitting CRUD method: delete($domainQn)")
        file += "    /**\n"
        file += "     * Deletes a $domainSimpleName entity from the database.\n"
        file += "     *\n"
        file += "     * Executes a DELETE statement based on the entity's ID.\n"
        file += "     *\n"
        if (!useContextParameters) {
            file += "     * @param context The query executor (database connection or transaction)\n"
        }
        file += "     * @param entity The $domainSimpleName entity to delete\n"
        file += "     * @return Result containing Unit on success,\n"
        file += "     *         or an error if the delete operation fails\n"
        file += "     */\n"
        if (useContextParameters) {
            file += "    context(context: QueryExecutor)\n"
            file += "    override suspend fun delete(entity: $domainQn) = run {\n"
        } else {
            file += "    override suspend fun delete(context: QueryExecutor, entity: $domainQn) = run {\n"
        }
        file += """        val hook = if (context is HookApi) context.hook as MutableHookEventBus else null
                           hook?.publish { CrudRepository.BeforeDeleteHook(entity, listOf($dependentTablesArg), context) }
                           val statement = entity.delete()
                           val result = context.execute(statement).map { kotlin.Unit }
                           hook?.publish { CrudRepository.AfterDeleteHook(entity, listOf($dependentTablesArg), result, context) }
                           result
                       }
                   """

        // save
        logger.info("[RepositoryProcessor] Emitting CRUD method: save($domainQn)")
        file += "    /**\n"
        file += "     * Saves a $domainSimpleName entity to the database.\n"
        file += "     *\n"
        file += "     * Automatically determines whether to INSERT (if entity is new) or\n"
        file += "     * UPDATE (if entity already exists) based on the ID field value.\n"
        file += "     * For Int IDs, 0 indicates a new entity. For Long IDs, 0L indicates new.\n"
        file += "     *\n"
        if (!useContextParameters) {
            file += "     * @param context The query executor (database connection or transaction)\n"
        }
        file += "     * @param entity The $domainSimpleName entity to save\n"
        file += "     * @return Result containing the saved $domainSimpleName entity,\n"
        file += "     *         or an error if the save operation fails\n"
        file += "     */\n"
        if (useContextParameters) {
            file += "    context(context: QueryExecutor)\n"
            file += "    override suspend fun save(entity: $domainQn) = run {\n"
        } else {
            file += "    override suspend fun save(context: QueryExecutor, entity: $domainQn) = run {\n"
        }
        val idProp: KSPropertyDeclaration? = domainDecl.getAllProperties().firstOrNull { p ->
            p.annotations.any { it.qualifiedName() == TypeNames.ID_ANNOTATION }
        }
        if (idProp == null) {
            file += "        error(\"No @Id property found in ${domainDecl.qualifiedName()}\")\n"
            file += "    }\n"
        } else {
            val idName = idProp.simpleName.getShortName()
            when (val idQn = idProp.type.resolve().declaration.qualifiedName()) {
                TypeNames.KOTLIN_INT, TypeNames.KOTLIN_LONG -> {
                    val zeroLiteral = if (idQn == TypeNames.KOTLIN_INT) "0" else "0L"
                    file += if (useContextParameters) {
                        "        if (entity.$idName == $zeroLiteral) insert(entity) else update(entity)\n"
                    } else {
                        "        if (entity.$idName == $zeroLiteral) insert(context, entity) else update(context, entity)\n"
                    }
                    file += "    }\n"
                }

                else -> {
                    file += "        error(\"@Id property '$idName' must be of type Int or Long in ${domainDecl.qualifiedName()}\")\n"
                    file += "    }\n"
                }
            }
        }
    }

    operator fun OutputStream.plusAssign(str: String): Unit = write(str.toByteArray())
    private fun KSDeclaration.qualifiedName(): String? = qualifiedName?.asString()
    private fun KSClassDeclaration.simpleName(): String = simpleName.asString()
    private fun KSFunctionDeclaration.simpleName(): String = simpleName.asString()
    private fun KSClassDeclaration.qualifiedName(): String? = qualifiedName?.asString()
    private fun KSAnnotation.qualifiedName(): String? = annotationType.resolve().declaration.qualifiedName?.asString()

    /**
     * Gets a string representation of the function's location that
     * IntelliJ can parse as a clickable link in the build console.
     *
     * @return A string like "(MyFile.kt:42)"
     */
    fun KSFunctionDeclaration.getLocationLink(): String {
        val file = this.containingFile ?: return "[Unknown File]"
        return file.filePath
    }

    companion object {
        /**
         * The default output file name used for generating repository implementations.
         * This constant is used in the code generation process to create output files
         * with a standardized and consistent naming convention.
         */
        private const val OUTPUT_FILENAME = "GeneratedRepositories"

        /**
         * Represents an option key used to enable or disable SQL syntax validation during the processing
         * of repository methods. Methods marked with the SQL validation flag will have their provided SQL
         * queries checked for syntax errors before being incorporated into the generated code.
         *
         * This key is typically used internally by the code generator to determine whether to invoke
         * the SQL syntax validation logic.
         */
        private const val VALIDATE_SQL_SYNTAX_OPTION: String = "validate-sql-syntax"

        /**
         * Represents the option key used to enable or disable SQL schema validation
         * during the repository processing phase. When this option is set, the
         * processor validates the defined schema against the repository's domain
         * and query definitions to ensure consistency and correctness.
         */
        private const val VALIDATE_SQL_SCHEMA_OPTION: String = "validate-sql-schema"

        /**
         * Represents the option key used for specifying the path to schema migration files
         * during repository processing and code generation.
         *
         * This constant is used to configure and resolve the directory containing
         * schema migration scripts, which are typically required for database structure
         * migration or initialization. The value associated with this option is expected
         * to be provided as part of the processing environment or tool configuration.
         */
        private const val SCHEMA_MIGRATIONS_PATH_OPTION: String = "schema-migrations-path"

        /**
         * Represents the option flag to enable context parameters for methods in repositories.
         * When this option is enabled, repository methods are expected to validate the presence
         * and correctness of a mandatory `context` parameter, which must be an instance of
         * `io.github.smyrgeorge.sqlx4k.QueryExecutor`.
         */
        private const val ENABLE_CONTEXT_PARAMETERS_OPTION: String = "enable-context-parameters"
    }
}
